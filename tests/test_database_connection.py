#!/usr/bin/env python3
"""
Comprehensive tests for Database Connection Safety and Performance
Generated by Flash model based on DeepSeek code review findings

Focus areas:
- Connection URL security and validation
- SQL injection prevention
- Transaction integrity and rollback
- Connection pooling and resource management
- Performance under load
"""

import pytest
import asyncio
import sys
import os
from unittest.mock import Mock, patch, AsyncMock
import asyncpg
import logging
from contextlib import asynccontextmanager

# Add project path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from database.connection import DatabaseManager, db_manager
from database.models import TaskInput, TaskOutput


class TestDatabaseConnection:
    """Comprehensive test suite for database connection safety and performance"""
    
    @pytest.fixture
    async def db_manager_instance(self):
        """Create a test database manager instance"""
        manager = DatabaseManager()
        yield manager
        # Cleanup
        try:
            if manager.pool:
                await manager.disconnect()
        except:
            pass

    @pytest.mark.asyncio
    async def test_connection_url_security(self, db_manager_instance):
        """Test that connection URLs don't expose sensitive information"""
        
        # Test with mock environment variables
        with patch.dict(os.environ, {
            'DB_USER': 'test_user',
            'DB_PASSWORD': 'secret_password_123!@#',
            'DB_HOST': 'localhost',
            'DB_PORT': '5432',
            'DB_NAME': 'test_db'
        }):
            
            # Mock asyncpg.create_pool to capture connection string
            captured_dsn = None
            
            async def mock_create_pool(dsn, **kwargs):
                nonlocal captured_dsn
                captured_dsn = dsn
                # Return a mock pool
                mock_pool = AsyncMock()
                mock_pool.close = AsyncMock()
                mock_pool.wait_closed = AsyncMock()
                return mock_pool
            
            with patch('asyncpg.create_pool', mock_create_pool):
                await db_manager_instance.connect()
                
                # Verify DSN contains expected components but is properly formatted
                assert captured_dsn is not None
                assert 'test_user' in captured_dsn
                assert 'secret_password_123!@#' in captured_dsn
                assert 'localhost' in captured_dsn
                assert 'test_db' in captured_dsn
                
                # Verify password is properly URL encoded if needed
                assert '@' in captured_dsn  # Should be present in user:pass@host format

    @pytest.mark.asyncio
    async def test_sql_injection_prevention(self, db_manager_instance):
        """Test that database queries prevent SQL injection"""
        
        # Create mock pool and connection
        mock_conn = AsyncMock()
        mock_pool = AsyncMock()
        mock_pool.acquire.return_value.__aenter__.return_value = mock_conn
        mock_pool.acquire.return_value.__aexit__.return_value = None
        
        db_manager_instance.pool = mock_pool
        
        # Test malicious input attempts
        malicious_inputs = [
            "'; DROP TABLE tasks; --",
            "admin'; UPDATE agents SET prompt = 'hacked' WHERE id = 1; --",
            "test' OR '1'='1",
            "test'; INSERT INTO tasks (status) VALUES ('malicious'); --"
        ]
        
        for malicious_input in malicious_inputs:
            # Simulate a query that might be vulnerable
            try:
                # This should use parameterized queries internally
                query = "SELECT * FROM agent_prompts WHERE agent_id = $1"
                mock_conn.fetchrow.return_value = None
                
                # Call a method that uses the database
                async with db_manager_instance.pool.acquire() as conn:
                    await conn.fetchrow(query, malicious_input)
                
                # Verify that the query was called with proper parameterization
                mock_conn.fetchrow.assert_called_with(query, malicious_input)
                
            except Exception as e:
                # Should not reach here in normal parameterized queries
                pytest.fail(f"Parameterized query failed unexpectedly: {e}")

    @pytest.mark.asyncio
    async def test_transaction_integrity(self, db_manager_instance):
        """Test transaction rollback on errors"""
        
        # Create mock pool and connection
        mock_conn = AsyncMock()
        mock_transaction = AsyncMock()
        mock_pool = AsyncMock()
        mock_pool.acquire.return_value.__aenter__.return_value = mock_conn
        mock_pool.acquire.return_value.__aexit__.return_value = None
        mock_conn.transaction.return_value = mock_transaction
        mock_transaction.__aenter__.return_value = mock_transaction
        mock_transaction.__aexit__.return_value = None
        
        db_manager_instance.pool = mock_pool
        
        # Test successful transaction
        async with db_manager_instance.pool.acquire() as conn:
            async with conn.transaction():
                await conn.execute("INSERT INTO tasks (job_id, agent_id, status) VALUES ($1, $2, $3)", 
                                 1, "AGENT_1", "PENDING")
                await conn.execute("UPDATE tasks SET status = $1 WHERE id = $2", "COMPLETED", 1)
        
        # Verify transaction was properly managed
        mock_transaction.__aenter__.assert_called()
        mock_transaction.__aexit__.assert_called()
        
        # Test transaction rollback on error
        mock_conn.execute.side_effect = [None, Exception("Database error")]
        
        with pytest.raises(Exception):
            async with db_manager_instance.pool.acquire() as conn:
                async with conn.transaction():
                    await conn.execute("INSERT INTO tasks (job_id, agent_id, status) VALUES ($1, $2, $3)",
                                     2, "AGENT_2", "PENDING")
                    await conn.execute("INVALID SQL THAT CAUSES ERROR")
        
        # Transaction should have been rolled back automatically

    @pytest.mark.asyncio
    async def test_connection_pool_management(self, db_manager_instance):
        """Test connection pool creation and cleanup"""
        
        # Mock asyncpg.create_pool
        mock_pool = AsyncMock()
        mock_pool.close = AsyncMock()
        mock_pool.wait_closed = AsyncMock()
        
        with patch('asyncpg.create_pool', return_value=mock_pool):
            # Test connection
            await db_manager_instance.connect()
            assert db_manager_instance.pool == mock_pool
            
            # Test disconnection
            await db_manager_instance.disconnect()
            mock_pool.close.assert_called_once()
            mock_pool.wait_closed.assert_called_once()
            assert db_manager_instance.pool is None

    @pytest.mark.asyncio
    async def test_connection_retry_logic(self, db_manager_instance):
        """Test connection retry mechanism on failure"""
        
        # Mock connection failures followed by success
        connection_attempts = []
        
        async def mock_create_pool_with_failures(dsn, **kwargs):
            connection_attempts.append(dsn)
            if len(connection_attempts) < 3:
                raise ConnectionError("Database unavailable")
            return AsyncMock()
        
        with patch('asyncpg.create_pool', mock_create_pool_with_failures):
            # This should implement retry logic (if implemented)
            try:
                await db_manager_instance.connect()
                # If retry logic exists, it should eventually succeed
            except ConnectionError:
                # If no retry logic, should fail on first attempt
                assert len(connection_attempts) == 1

    @pytest.mark.asyncio
    async def test_concurrent_database_access(self, db_manager_instance):
        """Test database performance under concurrent load"""
        
        # Create mock pool that supports concurrent access
        mock_pool = AsyncMock()
        mock_connections = [AsyncMock() for _ in range(10)]
        
        connection_index = 0
        async def mock_acquire():
            nonlocal connection_index
            conn = mock_connections[connection_index % len(mock_connections)]
            connection_index += 1
            return conn
        
        @asynccontextmanager
        async def mock_acquire_context():
            conn = await mock_acquire()
            yield conn
        
        mock_pool.acquire.return_value = mock_acquire_context()
        db_manager_instance.pool = mock_pool
        
        # Simulate concurrent database operations
        async def mock_database_operation(operation_id):
            async with db_manager_instance.pool.acquire() as conn:
                await asyncio.sleep(0.1)  # Simulate database work
                await conn.fetchrow("SELECT * FROM tasks WHERE id = $1", operation_id)
                return f"Operation {operation_id} completed"
        
        # Run multiple operations concurrently
        operations = [mock_database_operation(i) for i in range(10)]
        results = await asyncio.gather(*operations)
        
        # All operations should complete successfully
        assert len(results) == 10
        for i, result in enumerate(results):
            assert f"Operation {i} completed" == result

    @pytest.mark.asyncio
    async def test_database_error_handling(self, db_manager_instance):
        """Test proper error handling for various database errors"""
        
        mock_pool = AsyncMock()
        mock_conn = AsyncMock()
        mock_pool.acquire.return_value.__aenter__.return_value = mock_conn
        mock_pool.acquire.return_value.__aexit__.return_value = None
        
        db_manager_instance.pool = mock_pool
        
        # Test different types of database errors
        error_scenarios = [
            (asyncpg.ConnectionDoesNotExistError(), "Connection error"),
            (asyncpg.PostgresError(), "Postgres error"),
            (asyncpg.DataError(), "Data error"),
            (Exception("Generic database error"), "Generic error")
        ]
        
        for error, error_type in error_scenarios:
            mock_conn.fetchrow.side_effect = error
            
            with pytest.raises(type(error)):
                async with db_manager_instance.pool.acquire() as conn:
                    await conn.fetchrow("SELECT * FROM tasks")

    @pytest.mark.asyncio
    async def test_connection_string_validation(self, db_manager_instance):
        """Test validation of database connection parameters"""
        
        # Test missing required environment variables
        required_vars = ['DB_USER', 'DB_PASSWORD', 'DB_HOST', 'DB_PORT', 'DB_NAME']
        
        for var_to_remove in required_vars:
            env_without_var = {k: v for k, v in os.environ.items() if k != var_to_remove}
            
            with patch.dict(os.environ, env_without_var, clear=True):
                with patch('asyncpg.create_pool') as mock_create_pool:
                    # Should handle missing environment variables gracefully
                    try:
                        await db_manager_instance.connect()
                        # If connection succeeds, ensure it uses sensible defaults
                    except (KeyError, ValueError) as e:
                        # Expected behavior for missing required variables
                        assert var_to_remove.lower().replace('db_', '') in str(e).lower()

    @pytest.mark.asyncio
    async def test_database_health_check(self, db_manager_instance):
        """Test database health check functionality"""
        
        mock_pool = AsyncMock()
        mock_conn = AsyncMock()
        mock_pool.acquire.return_value.__aenter__.return_value = mock_conn
        mock_pool.acquire.return_value.__aexit__.return_value = None
        mock_conn.fetchval.return_value = 1
        
        db_manager_instance.pool = mock_pool
        
        # Test health check query
        async with db_manager_instance.pool.acquire() as conn:
            result = await conn.fetchval("SELECT 1")
            assert result == 1
        
        # Test health check with database error
        mock_conn.fetchval.side_effect = asyncpg.ConnectionDoesNotExistError()
        
        with pytest.raises(asyncpg.ConnectionDoesNotExistError):
            async with db_manager_instance.pool.acquire() as conn:
                await conn.fetchval("SELECT 1")

    @pytest.mark.asyncio
    async def test_connection_timeout_handling(self, db_manager_instance):
        """Test handling of connection timeouts"""
        
        async def mock_create_pool_with_timeout(dsn, **kwargs):
            # Simulate connection timeout
            await asyncio.sleep(0.1)
            raise asyncio.TimeoutError("Connection timeout")
        
        with patch('asyncpg.create_pool', mock_create_pool_with_timeout):
            with pytest.raises(asyncio.TimeoutError):
                await db_manager_instance.connect()

    @pytest.mark.asyncio
    async def test_pool_size_configuration(self, db_manager_instance):
        """Test connection pool size configuration"""
        
        captured_kwargs = {}
        
        async def mock_create_pool(dsn, **kwargs):
            captured_kwargs.update(kwargs)
            return AsyncMock()
        
        with patch('asyncpg.create_pool', mock_create_pool):
            await db_manager_instance.connect()
            
            # Verify that pool configuration parameters are reasonable
            # (This depends on actual implementation)
            if 'min_size' in captured_kwargs:
                assert captured_kwargs['min_size'] >= 1
            if 'max_size' in captured_kwargs:
                assert captured_kwargs['max_size'] >= captured_kwargs.get('min_size', 1)

    def test_connection_string_format_security(self):
        """Test that connection string formatting prevents injection"""
        
        # Test special characters in password
        test_credentials = [
            ("user", "pass@word", "host", "5432", "db"),
            ("user", "pass:word", "host", "5432", "db"),
            ("user", "pass/word", "host", "5432", "db"),
            ("user", "pass word", "host", "5432", "db"),
            ("user", "pass\"word", "host", "5432", "db"),
            ("user", "pass'word", "host", "5432", "db"),
        ]
        
        for user, password, host, port, db_name in test_credentials:
            # Simulate connection string building (implementation-dependent)
            # This test ensures special characters are properly handled
            dsn = f"postgresql://{user}:{password}@{host}:{port}/{db_name}"
            
            # Should not contain unescaped special characters that could break parsing
            # The actual implementation should use proper URL encoding or parameterization
            assert dsn.count('@') >= 1  # Should have at least one @ for user@host separation
            assert dsn.startswith('postgresql://')

    @pytest.mark.asyncio
    async def test_global_db_manager_instance(self):
        """Test the global db_manager instance"""
        
        # Test that global instance exists and is properly typed
        assert db_manager is not None
        assert isinstance(db_manager, DatabaseManager)
        
        # Test that it can be used for connections (with mocking)
        with patch('asyncpg.create_pool', return_value=AsyncMock()):
            await db_manager.connect()
            assert db_manager.pool is not None
            
            await db_manager.disconnect()
            assert db_manager.pool is None


if __name__ == "__main__":
    # Run specific tests
    pytest.main([__file__, "-v"])