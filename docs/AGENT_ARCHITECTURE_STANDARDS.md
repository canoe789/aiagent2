# Agent架构设计标准 (Agent Architecture Standards)

> **⚠️ 重要:** 本文档为所有Agent开发的**唯一权威规范**。所有Agent必须严格遵循这些标准，确保架构一致性和数据流兼容性。

**版本:** 1.0  
**基准:** 基于AGENT_1和AGENT_2的架构验证  
**状态:** 强制执行标准  

---

## 1. 标准Agent架构模式

### 1.1 统一架构模式定义

所有HELIX Agent必须遵循以下标准架构模式：

```python
# 标准Agent架构模式 (基于AGENT_1和AGENT_2验证)
class StandardAgent(BaseAgent):
    """
    标准Agent架构模式
    所有Agent必须遵循此模式确保架构一致性
    """
    
    def __init__(self):
        super().__init__("AGENT_X")  # 使用标准Agent ID
    
    async def process_task(self, task_input: TaskInput) -> TaskOutput:
        """
        标准任务处理流程 - 所有Agent必须实现
        """
        try:
            # 1. 日志记录和上下文提取
            logger.info("Processing task", agent_id=self.agent_id, 
                       artifact_count=len(task_input.artifacts))
            
            # 2. 获取输入构件 (P6: 统一构件引用协议)
            artifacts = await self.get_artifacts(task_input.artifacts)
            self._validate_required_artifacts(artifacts)
            
            # 3. 获取Agent提示词 (P3: 外部化认知)
            system_prompt = await self.get_agent_prompt()
            if not system_prompt:
                raise ValueError(f"No prompt found for {self.agent_id} - violates P3 principle")
            
            # 4. 生成输出 (AI优先 + 模板后备)
            output = await self._generate_output(artifacts, system_prompt)
            
            # 5. 记录成功事件
            await self.log_system_event("INFO", "Task completed successfully", 
                                       {"output_schema": output.schema_id})
            
            return output
            
        except Exception as e:
            logger.error("Task processing failed", agent_id=self.agent_id, error=str(e))
            await self.log_system_event("ERROR", f"Task failed: {str(e)}")
            raise
    
    async def _generate_output(self, artifacts: Dict[str, Any], system_prompt: str) -> TaskOutput:
        """
        标准输出生成流程 - AI优先 + 模板后备
        """
        try:
            # 尝试AI生成 (优先选择)
            ai_response = await self._generate_with_ai(artifacts, system_prompt)
            if ai_response:
                return ai_response
                
        except Exception as e:
            logger.warning("AI generation failed, falling back to template", error=str(e))
        
        # 模板后备生成
        return await self._generate_template_output(artifacts)
    
    async def _generate_with_ai(self, artifacts: Dict[str, Any], system_prompt: str) -> Optional[TaskOutput]:
        """
        AI生成方法 - 标准实现模式
        """
        # 创建AI客户端
        ai_client = AIClientFactory.create_client()
        
        # 增强提示词 (确保JSON输出)
        enhanced_prompt = f"""{system_prompt}

CRITICAL: You must respond with VALID JSON only. Do not include any text before or after the JSON.
The JSON must follow this exact structure to match {self.output_schema_id}:

{self._get_output_schema_template()}

Remember: Follow your internal thinking process, but output ONLY the final JSON result."""
        
        # 生成响应
        response = await ai_client.generate_response(
            system_prompt=enhanced_prompt,
            user_input=self._prepare_input_materials(artifacts),
            temperature=0.7,
            max_tokens=3000
        )
        
        # 解析响应
        return self._parse_ai_response(response["content"], response)
    
    def _parse_ai_response(self, content: str, response: Dict[str, Any]) -> Optional[TaskOutput]:
        """
        标准AI响应解析 - 移除markdown格式 + 添加元数据
        """
        try:
            # 移除markdown格式
            if content.startswith("```json"):
                content = content[7:]
            if content.endswith("```"):
                content = content[:-3]
            
            # 解析JSON
            payload = json.loads(content.strip())
            
            # 添加标准元数据
            if "metadata" not in payload:
                payload["metadata"] = {}
                
            payload["metadata"].update({
                "created_by": self.agent_id,
                "version": "1.0",
                "ai_model": response.get("model", "unknown"),
                "ai_provider": response.get("provider", "unknown"),
                "tokens_used": response.get("usage", {}).get("total_tokens", 0),
                "processing_notes": f"AI-generated by {self.agent_id}"
            })
            
            return TaskOutput(
                schema_id=self.output_schema_id,
                payload=payload
            )
            
        except json.JSONDecodeError as e:
            logger.warning("Failed to parse AI response as JSON", 
                          content_preview=content[:200], error=str(e))
            return None
    
    # 子类必须实现的抽象方法
    @property
    def output_schema_id(self) -> str:
        """返回输出Schema ID，如 'CreativeBrief_v1.0'"""
        raise NotImplementedError("Each agent must define output_schema_id")
    
    def _validate_required_artifacts(self, artifacts: Dict[str, Any]) -> None:
        """验证必需的输入构件"""
        raise NotImplementedError("Each agent must implement artifact validation")
    
    def _get_output_schema_template(self) -> str:
        """返回输出Schema模板用于AI提示词"""
        raise NotImplementedError("Each agent must provide schema template")
    
    def _prepare_input_materials(self, artifacts: Dict[str, Any]) -> str:
        """准备输入材料用于AI生成"""
        raise NotImplementedError("Each agent must implement input preparation")
    
    async def _generate_template_output(self, artifacts: Dict[str, Any]) -> TaskOutput:
        """模板后备生成方法"""
        raise NotImplementedError("Each agent must implement template fallback")
```

## 2. Agent间数据流标准

### 2.1 输入构件获取标准

```python
# 标准构件获取模式 (基于P6: 统一构件引用协议)
async def get_input_artifacts(self, task_input: TaskInput) -> Dict[str, Any]:
    """
    标准构件获取方法 - 所有Agent必须使用
    """
    artifacts = await self.get_artifacts(task_input.artifacts)
    
    # 验证必需构件
    required_artifacts = self.get_required_artifacts()
    for artifact_name in required_artifacts:
        if artifact_name not in artifacts:
            raise ValueError(f"Required artifact '{artifact_name}' not found")
    
    return artifacts

# 示例：AGENT_2获取AGENT_1输出
def get_required_artifacts(self) -> List[str]:
    return ["creative_brief"]  # 来自AGENT_1的输出
```

### 2.2 输出Schema验证标准

```python
# 标准输出验证 (基于P7: 构件自描述与验证)
async def validate_and_output(self, payload: Dict[str, Any]) -> TaskOutput:
    """
    标准输出验证方法 - 确保Schema兼容性
    """
    # 加载Schema进行验证
    schema_path = config.paths.get_schema_path(self.output_schema_id)
    with open(schema_path, 'r') as f:
        schema = json.load(f)
    
    # 验证payload
    jsonschema.validate(instance=payload, schema=schema)
    
    return TaskOutput(
        schema_id=self.output_schema_id,
        payload=payload
    )
```

### 2.3 数据流兼容性矩阵

| Agent | 输入构件 | 输出构件 | Schema ID |
|-------|----------|----------|-----------|
| AGENT_1 | 无 (用户chat_input) | creative_brief | CreativeBrief_v1.0 |
| AGENT_2 | creative_brief | visual_explorations | VisualExplorations_v1.0 |
| AGENT_3 | creative_brief, visual_explorations | presentation_blueprint | PresentationBlueprint_v1.0 |
| AGENT_4 | presentation_blueprint, creative_brief, visual_explorations | audit_report | AuditReport_v1.0 |
| AGENT_5 | system_failure_case, audit_report | evolution_proposal | EvolutionProposal_v1.0 |

## 3. Agent开发检查清单

### 3.1 架构一致性检查清单

开发任何新Agent前，必须完成以下检查：

- [ ] **P1: 代理架构** - 继承自BaseAgent，有明确的agent_id
- [ ] **P2: 持久化状态** - 使用统一的数据库接口，不维护内存状态
- [ ] **P3: 外部化认知** - 从数据库获取prompt，支持版本管理
- [ ] **P4: 幂等性** - 任务可重复执行，有完整的错误处理
- [ ] **P5: 历史学习** - 记录系统事件，支持后续分析
- [ ] **P6: 构件引用** - 使用轻量级引用，不传递大数据实体
- [ ] **P7: 自描述验证** - 输出严格符合JSON Schema

### 3.2 数据流兼容性检查清单

- [ ] **输入验证** - 验证所需构件是否存在
- [ ] **Schema匹配** - 输出Schema与下游Agent输入需求匹配
- [ ] **工作流配置** - workflows.json正确配置输入输出构件
- [ ] **元数据传递** - 包含必要的元数据供后续Agent使用
- [ ] **错误处理** - 优雅处理上游Agent的异常输出

### 3.3 代码质量检查清单

- [ ] **类型提示** - 所有方法有完整的类型注解
- [ ] **错误分类** - 正确使用RetryableError和NonRetryableError
- [ ] **日志记录** - 关键步骤有适当的日志记录
- [ ] **异步安全** - 正确使用async/await，避免阻塞操作
- [ ] **资源管理** - 正确关闭AI客户端和数据库连接

## 4. Agent实现示例

### 4.1 AGENT_1 (创意总监) - 参考实现

```python
class CreativeDirectorAgent(StandardAgent):
    """
    AGENT_1: 创意总监 - 首席故事官
    将用户需求转化为结构化创意简报
    """
    
    @property
    def output_schema_id(self) -> str:
        return "CreativeBrief_v1.0"
    
    def _validate_required_artifacts(self, artifacts: Dict[str, Any]) -> None:
        # AGENT_1不需要构件输入，直接处理用户chat_input
        pass
    
    def _get_output_schema_template(self) -> str:
        return '''
{
  "project_overview": {
    "title": "string",
    "type": "string", 
    "description": "string",
    "key_themes": ["string"]
  },
  "objectives": {
    "primary_goal": "string",
    "secondary_goals": ["string"],
    "success_metrics": ["string"]
  },
  "target_audience": {
    "primary_audience": "string",
    "audience_characteristics": {
      "demographics": "string",
      "psychographics": "string",
      "behavior_patterns": "string",
      "pain_points": "string",
      "motivations": "string"
    }
  },
  "creative_strategy": {
    "tone_of_voice": "string",
    "key_messages": ["string"],
    "creative_approach": "string"
  },
  "content_requirements": {
    "content_types": ["string"],
    "information_hierarchy": {
      "具体内容主题": 整数优先级(1-10)
    },
    "call_to_action": "string"
  },
  "metadata": {
    "created_by": "AGENT_1",
    "version": "1.0",
    "confidence_score": 0.85
  }
}'''
    
    def _prepare_input_materials(self, artifacts: Dict[str, Any]) -> str:
        # AGENT_1直接使用用户chat_input
        return self.current_task.input_data.get("params", {}).get("chat_input", "")
```

### 4.2 AGENT_2 (视觉总监) - 参考实现

```python
class VisualDirectorAgent(StandardAgent):
    """
    AGENT_2: 视觉总监 - 概念炼金师
    将创意简报转化为视觉主题探索
    """
    
    @property
    def output_schema_id(self) -> str:
        return "VisualExplorations_v1.0"
    
    def _validate_required_artifacts(self, artifacts: Dict[str, Any]) -> None:
        if "creative_brief" not in artifacts:
            raise ValueError("Required creative_brief artifact not found")
    
    def _get_output_schema_template(self) -> str:
        return '''
{
  "visual_themes": [
    {
      "name": "string",
      "description": "string", 
      "mood": "string",
      "inspiration": "string"
    }
  ],
  "style_direction": {
    "primary_style": "string",
    "visual_language": "string",
    "aesthetic_principles": ["string"]
  },
  "color_palette": {
    "primary_colors": ["#HEXCODE"],
    "secondary_colors": ["#HEXCODE"],
    "accent_colors": ["#HEXCODE"],
    "color_psychology": "string"
  },
  "typography": {
    "primary_font": "string",
    "secondary_font": "string",
    "font_hierarchy": "string", 
    "readability_notes": "string"
  },
  "layout_principles": {
    "grid_system": "string",
    "spacing_system": "string",
    "responsive_approach": "string"
  },
  "visual_elements": {
    "icons_style": "string",
    "imagery_style": "string",
    "graphic_elements": ["string"]
  },
  "metadata": {
    "created_by": "AGENT_2",
    "version": "1.0"
  }
}'''
    
    def _prepare_input_materials(self, artifacts: Dict[str, Any]) -> str:
        creative_brief = artifacts["creative_brief"]["payload"]
        return json.dumps({"creative_brief": creative_brief}, ensure_ascii=False, indent=2)
```

## 5. Agent测试标准

### 5.1 标准测试模式

```python
# 标准Agent测试
async def test_agent_standard_flow():
    """测试Agent标准流程"""
    agent = YourAgent()
    
    # 1. 测试输入验证
    with pytest.raises(ValueError):
        await agent.process_task(TaskInput(artifacts=[], params={}))
    
    # 2. 测试正常流程
    test_input = TaskInput(
        artifacts=[{"name": "required_artifact", "source_task_id": 101}],
        params={"test_param": "value"}
    )
    
    result = await agent.process_task(test_input)
    
    # 3. 验证输出格式
    assert result.schema_id == agent.output_schema_id
    assert "metadata" in result.payload
    assert result.payload["metadata"]["created_by"] == agent.agent_id
    
    # 4. 验证Schema兼容性
    jsonschema.validate(instance=result.payload, schema=load_schema(agent.output_schema_id))
```

### 5.2 数据流集成测试

```python
async def test_agent_data_flow():
    """测试Agent间数据流"""
    # 创建上游Agent输出
    upstream_output = TaskOutput(
        schema_id="CreativeBrief_v1.0",
        payload=create_mock_creative_brief()
    )
    
    # 创建下游Agent输入
    downstream_input = TaskInput(
        artifacts=[{"name": "creative_brief", "source_task_id": 101}],
        params={}
    )
    
    # 模拟数据流
    downstream_agent = VisualDirectorAgent()
    result = await downstream_agent.process_task(downstream_input)
    
    # 验证数据流兼容性
    assert result.schema_id == "VisualExplorations_v1.0"
    assert "visual_themes" in result.payload
```

## 6. 错误处理标准

### 6.1 标准错误处理模式

```python
# 标准错误处理模式
try:
    result = await self.process_core_logic(artifacts)
    return result
except RetryableError as e:
    # 可重试错误 - 记录但不终止
    logger.warning("Retryable error occurred", error=str(e))
    raise
except NonRetryableError as e:
    # 不可重试错误 - 记录并终止
    logger.error("Non-retryable error occurred", error=str(e))
    await self.log_system_event("ERROR", f"Fatal error: {str(e)}")
    raise
except Exception as e:
    # 未知错误 - 默认可重试
    logger.error("Unexpected error occurred", error=str(e))
    raise RetryableError(f"Unexpected error: {str(e)}")
```

### 6.2 错误分类指南

- **RetryableError**: 网络超时、AI模型临时不可用、资源锁定等
- **NonRetryableError**: 输入验证失败、Schema验证失败、认证错误等
- **ValidationError**: 构件格式错误、必需字段缺失等
- **SchemaValidationError**: 输出不符合JSON Schema要求

## 7. 性能优化标准

### 7.1 资源管理

```python
# 标准资源管理
async def _generate_with_ai(self, artifacts: Dict[str, Any], system_prompt: str) -> Optional[TaskOutput]:
    ai_client = None
    try:
        ai_client = AIClientFactory.create_client()
        response = await ai_client.generate_response(...)
        return self._parse_ai_response(response["content"], response)
    finally:
        if ai_client:
            await ai_client.close()  # 确保资源释放
```

### 7.2 缓存策略

```python
# 提示词缓存
@lru_cache(maxsize=10)
async def get_cached_prompt(self, version: str = "latest") -> str:
    return await self.get_agent_prompt(version)
```

## 8. 部署和监控

### 8.1 健康检查

```python
async def health_check(self) -> Dict[str, Any]:
    """Agent健康检查"""
    try:
        # 检查数据库连接
        await self.get_agent_prompt()
        
        # 检查AI客户端
        ai_client = AIClientFactory.create_client()
        await ai_client.test_connection()
        
        return {
            "status": "healthy",
            "agent_id": self.agent_id,
            "timestamp": datetime.utcnow().isoformat()
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "agent_id": self.agent_id,
            "error": str(e),
            "timestamp": datetime.utcnow().isoformat()
        }
```

### 8.2 监控指标

标准监控指标：
- 任务处理时间
- 成功率/失败率
- AI模型调用次数和成本
- 内存使用情况
- 错误类型分布

---

## 9. 版本控制和演进

### 9.1 Schema版本管理

```python
# Schema版本兼容性
class SchemaVersionManager:
    @staticmethod
    def is_compatible(current_version: str, required_version: str) -> bool:
        """检查Schema版本兼容性"""
        current_major = int(current_version.split('.')[0][1:])  # v1.0 -> 1
        required_major = int(required_version.split('.')[0][1:])  # v1.0 -> 1
        return current_major == required_major
```

### 9.2 Agent版本演进

- **向前兼容**: 新版本Agent必须能处理旧版本输入
- **向后兼容**: 新版本输出必须与旧版本Schema兼容
- **渐进升级**: 支持A/B测试和金丝雀发布

---

**📝 总结**

本文档为所有HELIX Agent开发提供了统一的架构标准和实现模式。严格遵循这些标准将确保：

1. **架构一致性** - 所有Agent遵循相同的设计模式
2. **数据流兼容性** - Agent间无缝数据传递
3. **可维护性** - 标准化的代码结构和错误处理
4. **可扩展性** - 支持新Agent的快速开发和集成
5. **可观测性** - 统一的日志记录和监控指标

所有Agent开发者必须将本文档作为开发的唯一权威参考，确保HELIX系统的整体架构一致性。